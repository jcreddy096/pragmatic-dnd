import {
  maxZIndex,
  monitorForElements
} from "./chunk-DSRATE4P.js";
import "./chunk-27OPL7CX.js";
import {
  isSafari
} from "./chunk-LBMA5UU2.js";
import "./chunk-GRBBAANK.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/element/custom-native-drag-preview/set-custom-native-drag-preview.js
function defaultOffset() {
  return {
    x: 0,
    y: 0
  };
}
function setCustomNativeDragPreview(_ref) {
  var render = _ref.render, nativeSetDragImage = _ref.nativeSetDragImage, _ref$getOffset = _ref.getOffset, getOffset = _ref$getOffset === void 0 ? defaultOffset : _ref$getOffset;
  var container = document.createElement("div");
  Object.assign(container.style, {
    // Ensuring we don't cause reflow when adding the element to the page
    // Using `position:fixed` rather than `position:absolute` so we are
    // positioned on the current viewport.
    // `position:fixed` also creates a new stacking context, so we don't need to do that here
    position: "fixed",
    // According to `mdn`, the element can be offscreen:
    // https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/setDragImage#imgelement
    //
    // However, that  information does not appear in the specs:
    // https://html.spec.whatwg.org/multipage/dnd.html#dom-datatransfer-setdragimage-dev
    //
    // If the element is _completely_ offscreen, Safari@17.1 will cancel the drag
    top: 0,
    left: 0,
    // Using maximum possible z-index so that this element will always be on top
    // https://stackoverflow.com/questions/491052/minimum-and-maximum-value-of-z-index
    // Did not use `layers` in `@atlaskit/theme` because:
    // 1. This element is not a 'layer' in the conventional sense, as this element
    //    is only created for a single frame for the browser to take a photo of it,
    //    and then it is destroyed
    // 2. Did not want to add a dependency onto `@atlaskit/theme`
    // 3. Want to always be on top of product UI which might have higher z-index's
    zIndex: maxZIndex,
    // Avoiding any additional events caused by the new element (being super safe)
    pointerEvents: "none"
  });
  document.body.append(container);
  var unmount = render({
    container
  });
  queueMicrotask(function() {
    var previewOffset = getOffset({
      container
    });
    if (isSafari()) {
      var rect = container.getBoundingClientRect();
      if (rect.width === 0) {
        return;
      }
      container.style.left = "-".concat(rect.width - 1e-4, "px");
    }
    nativeSetDragImage === null || nativeSetDragImage === void 0 || nativeSetDragImage(container, previewOffset.x, previewOffset.y);
  });
  function cleanup() {
    unbindMonitor();
    unmount === null || unmount === void 0 || unmount();
    document.body.removeChild(container);
  }
  var unbindMonitor = monitorForElements({
    // Remove portal in the dragstart event so that the user will never see it
    onDragStart: cleanup,
    // Backup: remove portal when the drop finishes (this would be an error case)
    onDrop: cleanup
  });
}
export {
  setCustomNativeDragPreview
};
//# sourceMappingURL=@atlaskit_pragmatic-drag-and-drop_element_set-custom-native-drag-preview.js.map
